from .config import get_config
import json
from langchain.tools import tool
from api.utils.console import print_to_console

config = get_config()
FILENAME = config['RAMDISK_DIR'] + "execute.lua"

def write_addresses(addresses_json):
	"""
	Generate a Lua script from an addresses payload and write it to execute.lua.
	`addresses_json` may be a dict, list, or JSON string. Returns (message, status_code).
	"""
	if addresses_json is None:
		return "Missing addresses", 400
	
	addresses = addresses_json

	# Normalize to a list of dicts
	addresses_list = []
	if isinstance(addresses, dict):
		addresses_list.append(addresses)
	elif isinstance(addresses, list):
		for item in addresses:
			if not isinstance(item, dict):
				return "addresses list must contain objects mapping address->value", 400
			addresses_list.append(item)
	else:
		return "addresses must be an object or list of objects", 400

	script_lines = ["-- LUA script generated by ffbot /nes/write endpoint"]

	for addr_map in addresses_list:
		for addr, val in addr_map.items():
			if isinstance(addr, str):
				addr_strip = addr.strip()
				if addr_strip.lower().startswith('0x'):
					addr_literal = addr_strip
				else:
					addr_literal = addr_strip
			else:
				addr_literal = str(addr)

			val_literal = None
			if isinstance(val, str):
				v = val.strip()
				try:
					if v.lower().startswith('0x'):
						val_literal = str(int(v, 16))
					else:
						val_literal = str(int(v))
				except Exception:
					val_literal = f'"{v}"'
			else:
				val_literal = str(val)

			script_lines.append(f'memory.writebyte("{addr_literal}", {val_literal})')

	lua_script = "\n".join(script_lines) + "\n"
	lua_script += "return 1 -- so that main daemon knows a script was executed and to clean up"

	print()
	print(lua_script)
	print()

	try:
		with open(FILENAME, 'w') as f:
			f.write(lua_script)
		return f"'{FILENAME}' written successfully", 200
	except Exception as e:
		return f"Error writing file: {e}", 500


# Provide a Langchain tool wrapper for write_addresses.
# The method is fault tolerant of the format of the input string, since
# LLMs often return differing formats of the JSON, or wrap values
# in quotes/backticks, use single quotes etc. We'll try multiple parsing
# strategies before giving up.
@tool
def write_addresses_tool(arg_str: str) -> str:
	"""
	LangChain tool wrapper around `write_addresses` that accepts a JSON string (provided by LLM)
	and returns a JSON string result (expected by the LLM).

	Input example: '[{"0x006BE4": 50}, {"0x006BE5": 0}]'
	"""
	print_to_console()
	print_to_console('Calling write_addresses tool:', color='yellow')
	print_to_console('arg_str = ' + str(arg_str))

	
	if arg_str is None:
		return '{"error": "Missing arg_str"}'

	# Work on a working copy and give it a descriptive name. LLM output may
	# include surrounding backticks, triple-backticks, or extra wrapping quotes.
	formatted_arg_str = str(arg_str).strip()

	# Remove surrounding backticks (LLM may wrap code in backticks)
	if (formatted_arg_str.startswith('`') and formatted_arg_str.endswith('`')) or (formatted_arg_str.startswith('```') and formatted_arg_str.endswith('```')):
		formatted_arg_str = formatted_arg_str.strip('`').strip()

	# If the whole thing is wrapped in quotes, unwrap once
	if (formatted_arg_str.startswith('"') and formatted_arg_str.endswith('"')) or (formatted_arg_str.startswith("'") and formatted_arg_str.endswith("'")):
		formatted_arg_str = formatted_arg_str[1:-1].strip()

	payload = None
	parse_errors = []

	# Attempt 1: normal JSON
	try:
		payload = json.loads(formatted_arg_str)
	except Exception as e:
		parse_errors.append(f'json.loads(formatted_arg_str) failed: {e}')

	# Attempt 2: Replace single quotes with double quotes (common LLM quirk)
	if payload is None:
		s2 = formatted_arg_str.replace("'", '"')
		try:
			payload = json.loads(s2)
		except Exception as e:
			parse_errors.append(f'json.loads(formatted_arg_str with single->double) failed: {e}')

	# Attempt 3: As a last resort try Python literal eval (handles Python dict/list syntax)
	if payload is None:
		try:
			import ast
			payload = ast.literal_eval(formatted_arg_str)
		except Exception as e:
			parse_errors.append(f'ast.literal_eval failed: {e}')

	if payload is None:
		# Return aggregated parse error info for debugging by LLM/user
		err_msg = ' | '.join(parse_errors)
		print_to_console('error parsing arg_str: ' + err_msg, 'red')
		return '{"error": "failed to parse arg_str: ' + err_msg.replace('"','') + '"}'

	# At this point payload is a Python object (dict or list). Accept both formats:
	# - A list of single-pair dicts: [{"0x006BE4": 50}, {"0x006BE5": 0}]
	# - A single dict mapping addresses to values: {"0x006BE4": 50, "0x006BE5": 0}
	# The underlying `write_addresses` already accepts either a dict or list, so
	# pass the payload directly.
	result, status = write_addresses(payload)
	if status != 200:
		print_to_console('error = ' + result, 'red')
		return '{"error": "' + result + '"}'

	try:
		print_to_console('result = ' + json.dumps(result))
		return json.dumps({"message": result})
	except Exception as e:
		print_to_console('error = ' + str(e), 'red')
		return '{"error": "' + str(e) + '"}'


__all__ = ["write_addresses", "write_addresses_tool"]
